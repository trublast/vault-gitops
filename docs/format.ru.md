# Декларативный формат ресурсов (create/update)

Формат для описания ресурсов, создаваемых/обновляемых через API по OpenAPI-спецификации. Учитываются только операции **create** и **update** (POST/PUT с телом запроса), без list/get.

## Связь с OpenAPI и vault-client-go

- **OpenAPI**: пути вида `/sys/mounts/{path}`, `/sys/policies/acl/{name}`; у операции есть `requestBody` → `$ref` на схему (например `MountsEnableSecretsEngineRequest`, `PoliciesWriteAclPolicyRequest`).
- **vault-client-go**: для каждой такой операции есть метод `OperationName(ctx, pathParam1, pathParam2, ..., requestBody)` — path-параметры и тело соответствуют OpenAPI.

Декларативный документ задаёт **уже подставленный path** (параметры вшиты в строку) и **тело запроса** `data`, совместимое со схемой этой операции.

---

## Минимальный формат (один ресурс)

```yaml
# Обязательно
path: <путь с подставленными path-параметрами>
data: <объект — тело запроса по схеме OpenAPI>

# Опционально
namespace: /  # для Vault — namespace; если не указан, не передаём заголовок
name: ""      # произвольное имя ресурса; должно быть уникальным (см. ниже)
revision: 0   # беззнаковое целое; участвует в расчёте digest (увеличьте, чтобы принудительно переприменить ресурс)
dependencies: []  # список имён ресурсов (name или namespace+path), от которых зависит данный (см. ниже)
ignore_failures: false  # при true ошибка применения не прерывает весь apply
method: POST     # HTTP-метод: GET или POST (по умолчанию POST); для GET тело не отправляется
```

- **path** — путь без префикса `/v1/` (префикс добавляется клиентом). В path уже подставлены параметры из OpenAPI, например:
  - `sys/policies/acl/{name}` → `sys/policies/acl/mypolicy`
  - `sys/mounts/{path}` → `sys/mounts/mykv`
- **CRUD и удаление ресурсов**: чтобы при удалении ресурса из yaml корректно вызывались DELETE в API, используйте пути, где идентификатор ресурса входит в path (те же, что и для read/update/delete в OpenAPI). Например, вместо `identity/group` (POST создаёт, но удалять нужно по id) — используйте `identity/group/name/my-group` (POST create/update, DELETE по тому же path). Аналогично: `identity/entity/name/my-entity`, `sys/policies/acl/mypolicy`, `sys/namespaces/ns1`, `auth/ldap/groups/dev-group`, `auth/ldap/users/ldap-user`. В Vault API есть некоторое число ресурсов, которые нельзя удалить по тому же пути, по которому они были созданы, например `pki/root/generate/internal`.
- **data** — JSON-объект тела запроса. Ключи и типы — как в OpenAPI (snake_case для Vault), в соответствии со схемой из `requestBody` операции, которая матчится по (method, path).
- **namespace** — неймспейс Vault для запроса (заголовок `X-Vault-Namespace`). Указывается, если ресурс создаётся не в root: например `ns1/` или `ns1/team/`. Ресурсы в root — без поля `namespace`.
- **name** — опциональное человекочитаемое имя ресурса. **Ключ в state** — всегда уникальное имя: если `name` задан, то он и есть ключ; если не задан — ключом служит **namespace + path**. Нормализованный namespace с завершающим `/` (например `ns1/`) склеивается с path: `ns=ns1`, `path=kv-v2/secret` → имя `ns1/kv-v2/secret`; для root namespace — только path, например `kv-v2/secret`. Линтер проверяет уникальность имён. При изменении только `name` (data не изменилось) запрос в API не отправляется — обновляется только state.
- **revision** — опциональное поле типа неотрицательное целое (unsigned), по умолчанию 0. Участвует в расчёте digest: при неизменном `data` ресурс не применяется повторно, но если увеличить `revision` (например с 0 до 1), digest меняется и ресурс будет применён заново. Нужно для принудительного пересоздания (ресурс удалён вручную, перегенерация сертификата или пароля и т.п.). Линтер проверяет, что значение не отрицательное.
- **dependencies** — опциональный список **имён** ресурсов (явное `name` или имя по умолчанию namespace+path). Ресурс применяется после всех перечисленных. Формат: список строк, например `[name1, name2]`. Порядок применения и удаления выводится по графу зависимостей (топологическая сортировка).
- **method** — опциональный HTTP-метод: `GET` или `POST` (по умолчанию `POST`). Для `GET` запрос отправляется без тела; используйте для read-only или list-эндпоинтов. Для `POST` объект `data` отправляется как JSON в теле запроса.

---

## Неймспейсы

**Создание неймспейсов** — по path `sys/namespaces/{path}` (CRUD: POST/DELETE). В path подставляется имя неймспейса или вложенный путь (`ns1`, `ns1/team`). Тело POST — схема `NamespacesCreateNamespaceRequest` (опционально `custom_metadata`), можно `data: {}`.

```yaml
---
path: sys/namespaces/ns1
data: {}
---
path: sys/namespaces/ns1/team
data: {}
```

**Ресурсы в неймспейсах**: у документа задаётся поле **namespace** (например `ns1/` или `ns1/team/`). Запрос к API выполняется с заголовком `X-Vault-Namespace: ns1/` — создание/обновление идёт в этом неймспейсе. При удалении ресурса из конфига DELETE тоже вызывается с тем же namespace.

**Порядок применения** задаётся только графом **dependencies**: применяется топологическая сортировка — ресурс создаётся после всех тех, от кого он зависит. Автоматической логики в данный момент нет: например, чтобы неймспейс создался раньше ресурсов в нём, у этих ресурсов нужно указать в `dependencies` имя ресурса-неймспейса (например `sys/namespaces/ns1`). Без зависимостей порядок определяется порядком ресурсов в списке.

---

## Шаблоны `<name:key>`

В полях **data** можно использовать подстановки из ответов API уже применённых ресурсов. Строка вида **`<name:key>`** при применении заменяется на значение из state: из сохранённого ответа (response_data) ресурса с указанным **именем** (`name`) берётся поле по точечному пути `key`.

- **name** — имя ресурса-источника (явное `name` из конфига или имя по умолчанию: namespace+path для ресурса без имени).
- **key** — путь по JSON ответа этого ресурса: вложенные поля через точку, элементы массива по индексу. Примеры: `client_token`, `keys.0`, `id`.

Шаблон распознаётся только если строка **целиком** заключена в угловые скобки и содержит ровно две части, разделённые `:`. Во всех остальных случаях строка не изменяется.

**Пример**: политика ссылается на `client_token`, выданный ресурсом с именем `token-create`:

```yaml
---
name: token-create
path: auth/token/create
data:
  policies: ["default"]
  ttl: 1h
---
name: save-token-to-kv
path: kv1/mysecret
dependencies:
  - token-create
data:
  token: <token-create:client_token>
```

**Важно**: ресурс с шаблоном должен **зависеть** от того ресурса, на который ссылается шаблон (через `dependencies` по имени), иначе порядок применения не гарантирован и подстановка может не найти ресурс в state.

---

## ignore_failures

Если задано **`ignore_failures: true`**, то при ошибке применения или удаления этого ресурса (ошибка подстановки шаблонов, неверный ответ API, ошибка сохранения state и т.д.) apply **не прерывается**: ошибка фиксируется, но остальные ресурсы продолжают применяться. По умолчанию любая ошибка по ресурсу останавливает весь apply.

Имеет смысл для опциональных или зависимых ресурсов (например, database connection при недоступной database), которые не должны блокировать остальные.

Ресурсы без метода DELETE в API (например `pki/root/generate/internal`): при удалении из конфига вызывается DELETE; если Vault возвращает 405 (Method Not Allowed) или 404, запись просто удаляется из state без ошибки.

---

## Несколько ресурсов (multi-document YAML)

Файл может содержать несколько документов через `---`; каждый документ — один ресурс (один create/update).

```yaml
---
path: sys/policies/acl/mypolicy
data:
  policy: |
    path "*" { capabilities = ["read"] }
---
path: sys/mounts/mykv
namespace: ns1/
data:
  type: kv
  description: ""
  config:
    default_lease_ttl: 0s
    max_lease_ttl: 0s
  local: false
  seal_wrap: false
  external_entropy_access: false
```

**Пример с зависимостями** (указываются имена ресурсов):

```yaml
---
name: ns1
path: sys/namespaces/ns1
data: {}
---
name: mykv
path: sys/mounts/mykv
namespace: ns1/
dependencies:
  - ns1
data:
  type: kv
  ...
---
name: ldap-config
path: auth/ldap/config
namespace: ns1/
dependencies:
  - ldap-mount
data:
  url: ldap://...
---
name: ldap-mount
path: sys/auth/ldap
namespace: ns1/
dependencies:
  - ns1
data: {}
```

---

## Резюме

| Поле       | Обязательное | По умолчанию | Описание |
|-----------|--------------|--------------|----------|
| `path`    | да           | —            | Путь с подставленными path-параметрами (без `/v1/`) |
| `data`    | да           | —            | Тело запроса по схеме OpenAPI для данной операции |
| `namespace` | нет        | не передавать | Неймспейс Vault для запроса (X-Vault-Namespace); ресурсы в неймспейсе задают, например, `ns1/` или `ns1/team/` |
| `name`     | нет          | ""            | Имя ресурса (ключ в state); если не задано — namespace+path (например ns/kv/mysecret или kv/mysecret в root); должно быть уникальным |
| `revision` | нет          | 0             | Неотрицательное целое; участвует в digest (увеличьте, чтобы принудительно переприменить ресурс) |
| `dependencies` | нет     | []           | Список имён ресурсов; порядок применения и удаления выводится по графу зависимостей |
| `ignore_failures` | нет  | false        | При true ошибка применения этого ресурса не прерывает apply |
| `method` | нет | POST | HTTP-метод: GET или POST; для GET тело не отправляется |

Минимум для одного ресурса: **path** + **data**. Остальное опционально.
